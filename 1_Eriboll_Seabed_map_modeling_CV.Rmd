---
title: "Loch Eriboll seabed map"
output:
  word_document: default
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: console
---

#To Do




3) Just a final tidy and upload to git hub - remove commented code




#setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


#setup
# Reset R's brain
rm(list=ls())

# getwd tells us where R is looking
getwd()
# setwd tells R where to look
setwd("F:/Seabed_map_paper")

 library(sp)
# library(seqinr)
# library(vegan)
# library(mvabund)
# library(plyr)
# library(MASS)
 library(RColorBrewer)
# library(gamm4)
 library(fields)
# library(KernSmooth)
# library(GISTools)
# library(maps)
# library(mapdata)
# library(maptools)
# #library(RgoogleMaps)
# library(PBSmapping)
 library(raster)
 library(rgdal)
# library(SpatialTools)
# library(rgeos)
# library(shapefiles)
# library(htmlTable)
# #library(fetchR)
 library(gstat)
# library(reshape)
# library(stratifyR)
# library(caret)
# 
 library(randomForest)
 library(mgcv)
library(climateStability)



#source('amazing_functions.R')



getwd()



########## import data

### .shp files
#cont<- readOGR(dsn='F:/SIFT2021/May on/GIS_data/analysis_files/terrain.shp', layer="terrain")

shore<- readOGR(dsn='F:/SIFT2021/May on/GIS_data/analysis_files/shoreline.shp', layer="shoreline")


new.ext<- extent(c(xmin=238800, xmax=252000, ymin=953700, ymax=969700))
new.ext

shore<- crop(shore, new.ext)



### rasters


### depth
depth <- raster(x = "F:/SIFT2021/May on/GIS_data/analysis_files/bathy.grd")

ter<- raster(x = "F:/Seabed_map_paper/Topo/topo.grd")

slo<- raster(x = "F:/Seabed_map_paper/Topo/slope.grd")
    
asp<- raster(x = "F:/Seabed_map_paper/Topo/aspect.grd")


dat<-read.csv("F:/SIFT2021/May on/Loch_Eriboll_substratum_combine_cob_boulder.csv")
head(dat)
str(dat)
names(dat)

sub<- subset(dat, dat$Substratum1!='')
sub<- sub[,-17]
sub<- droplevels(sub)


str(sub)
summary(sub)


sub$Substratum1<- as.factor(sub$Substratum1)
sub$Substratum2<- as.factor(sub$Substratum2)
sub$Substratum3<- as.factor(sub$Substratum3)

levels(sub$Substratum1)
sub$Substratum1<- factor(sub$Substratum1, levels = c("mud", "muddy_sand","sand", "gravel", "cob_boulder", "rock"))
levels(sub$Substratum1)

levels(sub$Substratum2)
sub$Substratum2<- factor(sub$Substratum2, levels = c("mud", "muddy_sand","sand", "gravel", "cob_boulder", "rock"))

levels(sub$Substratum3)
sub$Substratum3<- factor(sub$Substratum3, levels = c("sand", "cob_boulder"))

table(sub$Substratum1)
table(sub$Substratum2)
table(sub$Substratum3)





################################## coord system to assign if needed
###

#'#set CRS
CRS1.code <- CRS(SRS_string='EPSG:4326')

#Display the stored CRS using comment()
cat(comment(CRS1.code), "\n")
# Store the wkt in a variable
wkt1 <- comment(CRS1.code)

# Use this to assign the CRS of another sp-object
CRS.wgs84 <- CRS(SRS_string = wkt1)

### projections ####


CRS2.code <- CRS(SRS_string='EPSG:27700')
#Display the stored CRS using comment()
cat(comment(CRS2.code), "\n")
# Store the wkt in a variable
wkt2 <- comment(CRS2.code)

# Use this to assign the CRS of another sp-object
CRS.NG <- CRS(SRS_string = wkt2)


## make an spdf from the data
coord.tmp<- cbind(sub$x, sub$y)
sub.spdf<- SpatialPointsDataFrame(coord.tmp, data=data.frame(sub))
proj4string(sub.spdf) <- CRS.wgs84
sub.spdfT<- spTransform(sub.spdf,  CRS.NG)


```


#background map
```{r}


hill<- hillShade(slo, asp, angle=55, direction=100, normalize =T)


hill.col<- colorRampPalette(c('floralwhite','antiquewhite1', 'antiquewhite2', 'antiquewhite3', 'antiquewhite4'), bias=0.5)


depth.heat<- colorRampPalette(rev(brewer.pal(9,'Blues')[2:9]))



plot(hill, col=hill.col(1000), legend=F)
plot(depth, add=T, legend=F, col=depth.heat(1000))


```



#spatial data check plot
```{r Spatial data, include=FALSE}


plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(depth, add=T, col=depth.heat(1000), legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)
plot(sub.spdfT, pch=19, add=T, col='dodgerblue3', cex=1)


```

# plot substrata data
 
```{r}

head(sub.spdfT)
levels(sub.spdfT@data$Substratum1)
levels(sub.spdfT@data$Substratum2)
levels(sub.spdfT@data$Substratum3)

#display.brewer.all()

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(depth, add=T, col=depth.heat(1000), legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)


###area calc
plot(depth, colNA="dodgerblue")

cell.No<-cellStats(depth, function(i, ...) sum(!is.na(i)))

raster_area<- cell.No * (res(depth)[1]*res(depth)[2])


total.area <- round(raster_area/(1000*1000), 2)




sub.spdfT@data$Substratum2<- as.factor(sub.spdfT@data$Substratum2)
sub.spdfT@data$Substratum3<- as.factor(sub.spdfT@data$Substratum3)



plot(sub.spdfT, pch=19, add=T, col=
       brewer.pal(8,"Dark2")[sub.spdfT@data$Substratum1], cex=2)

sub.spdfT2<- sub.spdfT[,15]
sub.spdfT3<- sub.spdfT[,16]


### write function to remove '' from spatial data
sp.na.omit <- function(x, margin=1) {
  if (!inherits(x, "SpatialPointsDataFrame") & !inherits(x, "SpatialPolygonsDataFrame")) 
    stop("MUST BE sp SpatialPointsDataFrame OR SpatialPolygonsDataFrame CLASS OBJECT") 
  na.index <- unique(as.data.frame(which(is.na(x@data),arr.ind=TRUE))[,margin])
    if(margin == 1) {  
      cat("DELETING ROWS: ", na.index, "\n") 
        return( x[-na.index,]  ) 
    }
    if(margin == 2) {  
      cat("DELETING COLUMNS: ", na.index, "\n") 
        return( x[,-na.index]  ) 
    }
 }

# DELETE NA's IN meuse AND SHOW CHANGE IN dim
sub.spdfT2.trim <- sp.na.omit(sub.spdfT2)     
  dim(sub.spdfT2)
    dim(sub.spdfT2.trim)
    
sub.spdfT2.trim@data$Substratum2<- factor(sub.spdfT2.trim@data$Substratum2, levels = c("mud", "muddy_sand","sand", "gravel", "cob_boulder", "rock"))


plot(sub.spdfT2, col="red", pch=20)
  plot(sub.spdfT2.trim, col="black", pch=20, add=TRUE)
  
sub.spdfT3.trim <- sp.na.omit(sub.spdfT3)     
  dim(sub.spdfT3)
    dim(sub.spdfT3.trim) 
    
sub.spdfT3.trim@data$Substratum3<- factor(sub.spdfT3.trim@data$Substratum3, levels = c("sand", "cob_boulder"))
    
plot(sub.spdfT3, col="red", pch=20)
  plot(sub.spdfT3.trim, col="black", pch=20, add=TRUE)
  
  
  
  
#pdf(file="F:/SIFT2021/May on/report/sample_point_results.pdf",width=6, height=6)

  

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(depth, add=T, col=depth.heat(1000), legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       brewer.pal(8,"Dark2")[c(2:6,8)][sub.spdfT@data$Substratum1], cex=1.5)

plot(sub.spdfT2.trim, pch=19, add=T, col=
       brewer.pal(8,"Dark2")[c(2:6,8)][sub.spdfT2.trim@data$Substratum2], cex=1)

plot(sub.spdfT3.trim, pch=19, add=T, col=
       brewer.pal(8,"Dark2")[c(4,6)][sub.spdfT3.trim@data$Substratum3], cex=0.5)


leg<- c("mud", "muddy sand", "sand", "gravel", "cobble boulder", "rock" )

legend('bottomright', legend=leg, fill= brewer.pal(8,"Dark2")[c(2:6,8)], bg='white')


#dev.off()  

# 
# levels(sub.spdfT@data$Substratum1)
# levels(sub.spdfT2.trim@data$Substratum2)
# levels(sub.spdfT3.trim@data$Substratum3)
# levels(sub.spdfT4.trim@data$Substratum4)


```



### GAM krig - follow this example
https://www.r-exercises.com/2018/03/31/advanced-techniques-with-raster-data-part-3-regression-kriging/
#Mud
```{r}

# 
# 
# # Check data for duplicates..
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
# # define some  functions for creating the k-fold train/test data splits and for obtaining the regression residuals out of a random forest object:
# 
# # Generate the K-fold train--test splits
# # x are the row indices
# # Outputs a list with test (or train) indices
# #### initially just do loo_CV so k= nrow(data)
# 
# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF object
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# # define some  parameters, get the test/train splits with the function kfoldSplit and initialize the matrix that will store all RMSE values (one for each training round and modelling technique; evalData object).
# 
# 
# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.mud <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
# #### (train) residuals are interpolated through kriging and then (test) residuals are added to (test) regression results for evaluation
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "mud"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- mud ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mud[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "mud"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mud[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = mud ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = mud ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  

}


 


round(apply(evalData.mud,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.mud,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])
# 

```




## Mud model predictions
```{r}

### GAM_OK
#For this we will not use any test/train partition but the entire dataset:

# refit model to all


GAM1 <- gam(formula = mud ~  s(x, y)+ depth, data = sub.spdfT, family = binomial)
summary(GAM1)
#plot(GAM1)


## make data frame for predictions

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'= xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)
head(PredGAM)

coord.tmp<- cbind(PredGAM$x, PredGAM$y)
mud.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(mud.spdf) <- CRS.wgs84
mud.spdfT<- spTransform(mud.spdf,  CRS.NG)

#plot(mud.spdfT)




mud.r<-rasterize(mud.spdfT, depth, 'fit', fun=mean)
#plot(mud.r)


### start here use this as the standard for other model implementation

#plot(mud.r)
display.brewer.all()
prob.heat<- colorRampPalette(brewer.pal(11,'Spectral'))


#pdf(file="F:/SIFT2021/May on/report/mud_pred.pdf",width=6, height=6)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)

plot(mud.r, add=T, legend=FALSE, axes=FALSE, col=prob.heat(1000) )

plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "mud" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[2], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "mud" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[2], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c( brewer.pal(8,"Dark2")[c(2)], 'black', 'black', 'black', 'black', 'black'))


#dev.off()


```

## Mud RF prediction
```{r}

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])
summary(mod.dat.rf)
mod.dat.rf<- na.omit(mod.dat.rf)
summary(mod.dat.rf)
names(sub)

RF.mod<- randomForest(y = as.factor(sub$mud), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)
summary(Pred.rf)
names(Pred.rf)[3]<- c('fit')
str(Pred.rf)
Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

mud.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(mud.rf.spdf) <- CRS.wgs84
mud.rf.spdfT<- spTransform(mud.rf.spdf,  CRS.NG)



mud.rf.r<-rasterize(mud.rf.spdfT, depth, 'fit')
#plot(mud.rf.r)


#pdf(file="F:/SIFT2021/May on/report/mud_RF.pdf",width=6, height=6)

#plot(mud.r)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(mud.rf.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "mud" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[2], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "mud" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[2], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[3:6][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[c(3,5,6)][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c( brewer.pal(8,"Dark2")[c(2)], 'black', 'black', 'black', 'black', 'black'))

#dev.off()

```

##mud krig
```{r}

# re fit model to all data

 formMod <- mud ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  plot(variog, variogFitOLS, main="OLS Model")
#
  
  



#all.points.spdfT<-rasterToPoints(depth,spatial=TRUE)


xy<- projectRaster(depth, crs=CRS.wgs84, method="bilinear")
new.dat<- data.frame(rasterToPoints(xy,spatial=F))
colnames(new.dat)<- c('x','y', 'depth')

 coord.tmp<- cbind(new.dat$x, new.dat$y)
new.dat.spdf<- SpatialPointsDataFrame(coord.tmp, data=data.frame(new.dat),  proj4string= CRS.wgs84)
new.dat.spdfT<- sp::spTransform(new.dat.spdf, CRS.NG)    
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



# make depth raster
mud.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


mud.k<- rescale0to1(mud.k)



#pdf(file="F:/SIFT2021/May on/report/mud_K_pred.pdf",width=6, height=6)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(mud.k, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "mud" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[2], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "mud" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[2], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c( brewer.pal(8,"Dark2")[c(2)], 'black', 'black', 'black', 'black', 'black'))


#dev.off()

#hist(mud.k)

```



# Muddy_sand
```{r}
 
# 
# # Check data for duplicates..
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
# # define some  functions for creating the k-fold train/test data splits and for obtaining the regression residuals out of a random forest object:
# 
# # Generate the K-fold train--test splits
# # x are the row indices
# # Outputs a list with test (or train) indices
# #### initially just do loo_CV so k= nrow(data)
# 
# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF object
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# # define some  parameters, get the test/train splits with the function kfoldSplit and initialize the matrix that will store all RMSE values (one for each training round and modelling technique; evalData object).
# 
# 
# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.mudSand <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
# #### (train) residuals are interpolated through kriging and then (test) residuals are added to (test) regression results for evaluation
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "muddy_sand"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- muddy_sand ~ x+y+ depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mudSand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "muddy_sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mudSand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = muddy_sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = muddy_sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
}


 


round(apply(evalData.mudSand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.mudSand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])
# 

 

```


## Muddy_sand model predictions
```{r}

### GAM_OK
#For this we will not use any test/train partition but the entire dataset:

# refit model to all


GAM1 <- gam(formula = muddy_sand ~  s(x, y)+ depth, data = sub.spdfT, family = binomial)
summary(GAM1)
#plot(GAM1)

## make data frame for predictions

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'= xy[,1],'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)
head(PredGAM)

coord.tmp<- cbind(PredGAM$x, PredGAM$y)
muddy_sand.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(muddy_sand.spdf) <- CRS.wgs84
muddy_sand.spdfT<- spTransform(muddy_sand.spdf,  CRS.NG)

#plot(muddy_sand.spdfT)




muddy_sand.r<-rasterize(muddy_sand.spdfT, depth, 'fit', fun=mean)
#plot(muddy_sand.r)



#pdf(file="F:/SIFT2021/May on/report/muddy_sand_pred.pdf",width=6, height=6)



plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(muddy_sand.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)





plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "muddy_sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[3], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "muddy_sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[3], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
 #      brewer.pal(8,"Dark2")[3:6][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[c(3,5,6)][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c('1', brewer.pal(8,"Dark2")[c(3)], '1', '1', '1','1'))

#dev.off()






# 

```

## Muddy_sand RF prediction
```{r}

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])
summary(mod.dat.rf)
mod.dat.rf<- na.omit(mod.dat.rf)
summary(mod.dat.rf)
names(sub)

RF.mod<- randomForest(y = as.factor(sub$muddy_sand), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)
summary(Pred.rf)
names(Pred.rf)[3]<- c('fit')
str(Pred.rf)
Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

muddy_sand.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(muddy_sand.rf.spdf) <- CRS.wgs84
muddy_sand.rf.spdfT<- spTransform(muddy_sand.rf.spdf,  CRS.NG)










muddy_sand.rf.r<-rasterize(muddy_sand.rf.spdfT, depth, 'fit', fun=mean)
#plot(muddy_sand.rf.r)

#pdf(file="F:/SIFT2021/May on/report/muddy_s_RF.pdf",width=6, height=6)



plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(muddy_sand.rf.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)


plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "muddy_sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[3], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "muddy_sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[3], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
 #      brewer.pal(8,"Dark2")[3:6][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[c(3,5,6)][sub.spdfT4.trim@data$Substratum4], cex=2.4)

legend('bottomright', legend=leg, fill=c('1', brewer.pal(8,"Dark2")[c(3)], '1', '1', '1','1'))

#dev.off()

```


#muddy_sand krig
```{r}

# re fit model to all data

 formMod <- muddy_sand ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  plot(variog, variogFitOLS, main="OLS Model")
#
  
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



# make depth raster
muddy_sand.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


muddy_sand.k<- rescale0to1(muddy_sand.k)




#pdf(file="F:/SIFT2021/May on/report/muddy_sand_k.pdf",width=6, height=6)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(muddy_sand.k, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "muddy_sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[3], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "muddy_sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[3], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c('black', brewer.pal(8,"Dark2")[c(3)], 'black', 'black', 'black', 'black'))


#dev.off()

#hist(muddy_sand.k)

```


# sand
```{r}

# 
# # Check data for duplicates..
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
# # define some  functions for creating the k-fold train/test data splits and for obtaining the regression residuals out of a random forest object:
# 
# # Generate the K-fold train--test splits
# # x are the row indices
# # Outputs a list with test (or train) indices
# #### initially just do loo_CV so k= nrow(data)
# 
# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF object
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# # define some  parameters, get the test/train splits with the function kfoldSplit and initialize the matrix that will store all RMSE values (one for each training round and modelling technique; evalData object).
# 
# 
# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.sand <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
# #### (train) residuals are interpolated through kriging and then (test) residuals are added to (test) regression results for evaluation
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "sand"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- sand ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.sand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.sand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 

#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 

#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 
}


 


round(apply(evalData.sand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.sand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])
# 


```


## sand model predictions
```{r}

### GAM_OK
#For this we will not use any test/train partition but the entire dataset:

# refit model to all


GAM1 <- gam(formula = sand ~  s(x, y)+ depth, data = sub.spdfT, family = binomial)
summary(GAM1)
#plot(GAM1)

## make data frame for predictions

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)
head(PredGAM)

coord.tmp<- cbind(PredGAM$x, PredGAM$y)
sand.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(sand.spdf) <- CRS.wgs84
sand.spdfT<- spTransform(sand.spdf,  CRS.NG)

#plot(sand.spdfT)




sand.r<-rasterize(sand.spdfT, depth, 'fit', fun=mean)
#plot(sand.r)

#pdf(file="F:/SIFT2021/May on/report/sand_pred.pdf",width=6, height=6)


plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(sand.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)


plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[4], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[4], cex=1.1)

plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "sand" ,], pch=19, add=T, col=
     brewer.pal(8,"Dark2")[4], cex=1.1)

#plot(sub.spdfT4.trim[sub.spdfT4.trim$Substratum4 == "sand" ,], pch=19, add=T, col=
     #  brewer.pal(8,"Dark2")[3], cex=1.1)


legend('bottomright', legend=leg, fill=c('1', '1', brewer.pal(8,"Dark2")[c(4)], '1', '1', '1'))



#dev.off()




```

## sand RF prediction
```{r}
#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])
summary(mod.dat.rf)
mod.dat.rf<- na.omit(mod.dat.rf)
summary(mod.dat.rf)
names(sub)

RF.mod<- randomForest(y = as.factor(sub$sand), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)
summary(Pred.rf)
names(Pred.rf)[3]<- c('fit')
str(Pred.rf)
Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

sand.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(sand.rf.spdf) <- CRS.wgs84
sand.rf.spdfT<- spTransform(sand.rf.spdf,  CRS.NG)




sand.rf.r<-rasterize(sand.rf.spdfT, depth, 'fit', fun=mean)
#plot(sand.rf.r)


#pdf(file="F:/SIFT2021/May on/report/sand_RF.pdf",width=6, height=6)


plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(sand.rf.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[4], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[4], cex=1.1)

plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "sand" ,], pch=19, add=T, col=
     brewer.pal(8,"Dark2")[4], cex=1.1)



legend('bottomright', legend=leg, fill=c('1', '1', brewer.pal(8,"Dark2")[c(4)], '1', '1', '1'))


#dev.off()

```


#sand krig
```{r}

# re fit model to all data

 formMod <- sand ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  plot(variog, variogFitOLS, main="OLS Model")
#
  
  
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



# make depth raster
sand.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


sand.k<- rescale0to1(sand.k)




#pdf(file="F:/SIFT2021/May on/report/sand_K_pred.pdf",width=6, height=6)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(sand.k, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[4], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "sand" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[4], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c('black', 'black', brewer.pal(8,"Dark2")[c(4)], 'black', 'black', 'black'))


#dev.off()

#hist(sand.k)

```



# gravel
```{r}
# 

# # Check data for duplicates..
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
# # define some  functions for creating the k-fold train/test data splits and for obtaining the regression residuals out of a random forest object:
# 
# # Generate the K-fold train--test splits
# # x are the row indices
# # Outputs a list with test (or train) indices
# #### initially just do loo_CV so k= nrow(data)
# 
# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF object
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# # define some  parameters, get the test/train splits with the function kfoldSplit and initialize the matrix that will store all RMSE values (one for each training round and modelling technique; evalData object).
# 
# 
# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.gravel <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
# #### (train) residuals are interpolated through kriging and then (test) residuals are added to (test) regression results for evaluation
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "gravel"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- gravel ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.gravel[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "gravel"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.gravel[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = gravel ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  

#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = gravel ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  

}


 


round(apply(evalData.gravel,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.gravel,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])
# 

```


## gravel model predictions
```{r}

### GAM_OK
#For this we will not use any test/train partition but the entire dataset:

# refit model to all


GAM1 <- gam(formula = gravel ~  s(x,y)+ depth, data = sub.spdfT, family = binomial)
summary(GAM1)
#plot(GAM1)

## make data frame for predictions

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)
head(PredGAM)

coord.tmp<- cbind(PredGAM$x, PredGAM$y)
gravel.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(gravel.spdf) <- CRS.wgs84
gravel.spdfT<- spTransform(gravel.spdf,  CRS.NG)

#plot(gravel.spdfT)




gravel.r<-rasterize(gravel.spdfT, depth, 'fit', fun=mean)
#plot(gravel.r)



#pdf(file="F:/SIFT2021/May on/report/gravel_pred.pdf",width=6, height=6)


plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(gravel.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)


plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "gravel" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[5], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "gravel" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[5], cex=1.1)

#plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "gravel" ,], pch=19, add=T, col=
  #   brewer.pal(8,"Dark2")[4], cex=1.1)

#plot(sub.spdfT4.trim[sub.spdfT4.trim$Substratum4 == "sand" ,], pch=19, add=T, col=
 #      brewer.pal(8,"Dark2")[4], cex=1.1)


legend('bottomright', legend=leg, fill=c('1','1','1', brewer.pal(8,"Dark2")[c(5)], '1', '1'))

#dev.off()

# 

```

## gravel RF prediction
```{r}

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])
summary(mod.dat.rf)
mod.dat.rf<- na.omit(mod.dat.rf)
summary(mod.dat.rf)
names(sub)

RF.mod<- randomForest(y = as.factor(sub$gravel), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)
summary(Pred.rf)
names(Pred.rf)[3]<- c('fit')
str(Pred.rf)
Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

gravel.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(gravel.rf.spdf) <- CRS.wgs84
gravel.rf.spdfT<- spTransform(gravel.rf.spdf,  CRS.NG)



gravel.rf.r<-rasterize(gravel.rf.spdfT, depth, 'fit', fun=mean)
#plot(gravel.rf.r)


#pdf(file="F:/SIFT2021/May on/report/gravel_RF.pdf",width=6, height=6)


plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(gravel.rf.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "gravel" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[5], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "gravel" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[5], cex=1.1)

#plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "gravel" ,], pch=19, add=T, col=
#     brewer.pal(8,"Dark2")[5], cex=1.1)

#plot(sub.spdfT4.trim[sub.spdfT4.trim$Substratum4 == "sand" ,], pch=19, add=T, col=
    #   brewer.pal(8,"Dark2")[4], cex=1.1)



legend('bottomright', legend=leg, fill=c('1','1','1', brewer.pal(8,"Dark2")[c(5)], '1', '1'))

#dev.off()

```


#gravel krig
```{r}

# re fit model to all data

 formMod <- gravel ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  plot(variog, variogFitOLS, main="OLS Model")
#
  
 
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



# make depth raster
gravel.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


gravel.k<- rescale0to1(gravel.k)



#pdf(file="F:/SIFT2021/May on/report/gravel_K_pred.pdf",width=6, height=6)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(gravel.k, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "gravel" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[5], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "gravel" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[5], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c('black', 'black', 'black', brewer.pal(8,"Dark2")[c(5)], 'black', 'black'))


#dev.off()

```






#Cobble-boulder joint
```{r}

# 
# # Check data for duplicates..
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
# # define some  functions for creating the k-fold train/test data splits and for obtaining the regression residuals out of a random forest object:
# 
# # Generate the K-fold train--test splits
# # x are the row indices
# # Outputs a list with test (or train) indices
# #### initially just do loo_CV so k= nrow(data)
# 
# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF object
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# # define some  parameters, get the test/train splits with the function kfoldSplit and initialize the matrix that will store all RMSE values (one for each training round and modelling technique; evalData object).
# 
# 
# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.cob <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
# #### (train) residuals are interpolated through kriging and then (test) residuals are added to (test) regression results for evaluation
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "cob_boulder"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- cob_boulder ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.cob[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "cob_boulder"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.cob[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  

#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = cob_boulder ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  

#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = cob_boulder ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
}


 


round(apply(evalData.cob,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.cob,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])
# 

```


## Cob_boulder model predictions
```{r}

### GAM_OK
#For this we will not use any test/train partition but the entire dataset:

# refit model to all


GAM1 <- gam(formula = cob_boulder ~  s(x,y)+ depth, data = sub.spdfT, family = binomial)
summary(GAM1)
#plot(GAM1)

## make data frame for predictions

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val,'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)
head(PredGAM)

coord.tmp<- cbind(PredGAM$x, PredGAM$y)
cob_boulder.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(cob_boulder.spdf) <- CRS.wgs84
cob_boulder.spdfT<- spTransform(cob_boulder.spdf,  CRS.NG)

#plot(boulder.spdfT)




cob_boulder.r<-rasterize(cob_boulder.spdfT, depth, 'fit', fun=mean)
#plot(boulder.r)


#pdf(file="F:/SIFT2021/May on/report/cob_boulder_pred.pdf",width=6, height=6)




plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(cob_boulder.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)


plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "cob_boulder" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[6], cex=1.1)


plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "cob_boulder" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[6], cex=1.1)

plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "cob_boulder" ,], pch=19, add=T, col=
     brewer.pal(8,"Dark2")[6], cex=1.1)



# plot(sub.spdfT4.trim[sub.spdfT4.trim$Substratum4 == "boulder" ,], pch=19, add=T, col=
#        brewer.pal(8,"Dark2")[6], cex=1.1)
# 


legend('bottomright', legend=leg, fill=c('1','1','1','1', brewer.pal(8,"Dark2")[c(6)],'1'))

#dev.off()


```

## Cob-boulder RF prediction
```{r}

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])
summary(mod.dat.rf)
mod.dat.rf<- na.omit(mod.dat.rf)
summary(mod.dat.rf)
names(sub)

RF.mod<- randomForest(y = as.factor(sub$cob_boulder), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)
summary(Pred.rf)
names(Pred.rf)[3]<- c('fit')
str(Pred.rf)
Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

cob_boulder.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(cob_boulder.rf.spdf) <- CRS.wgs84
cob_boulder.rf.spdfT<- spTransform(cob_boulder.rf.spdf,  CRS.NG)



cob_boulder.rf.r<-rasterize(cob_boulder.rf.spdfT, depth, 'fit', fun=mean)
#plot(boulder.rf.r)


#pdf(file="F:/SIFT2021/May on/report/Cob_b_RF.pdf",width=6, height=6)


plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(cob_boulder.rf.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)


plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "cob_boulder" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[6], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "cob_boulder" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[6], cex=1.1)

plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "cob_boulder" ,], pch=19, add=T, col=
     brewer.pal(8,"Dark2")[6], cex=1.1)



legend('bottomright', legend=leg, fill=c('1','1','1','1', brewer.pal(8,"Dark2")[c(6)],'1'))

#dev.off()

```


#Cob_boulder krig
```{r}

# re fit model to all data

 formMod <- cob_boulder ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  plot(variog, variogFitOLS, main="OLS Model")
#
     
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



# make depth raster
cob_boulder.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


cob_boulder.k<- rescale0to1(cob_boulder.k)



#pdf(file="F:/SIFT2021/May on/report/cob_boulder_K_pred.pdf",width=6, height=6)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(cob_boulder.k, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "cob_boulder" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[6], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "cob_boulder" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[6], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c( 'black', 'black', 'black', 'black', brewer.pal(8,"Dark2")[c(6)], 'black'))


#dev.off()

#hist(cob_boulder.k)

```


# rock
```{r}
# 
# 
# # Check data for duplicates..
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
# # define some  functions for creating the k-fold train/test data splits and for obtaining the regression residuals out of a random forest object:
# 
# # Generate the K-fold train--test splits
# # x are the row indices
# # Outputs a list with test (or train) indices
# #### initially just do loo_CV so k= nrow(data)
# 
# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF object
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# # define some  parameters, get the test/train splits with the function kfoldSplit and initialize the matrix that will store all RMSE values (one for each training round and modelling technique; evalData object).
# 
# 
# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.rock <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
# #### (train) residuals are interpolated through kriging and then (test) residuals are added to (test) regression results for evaluation
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "rock"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- rock ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.rock[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "rock"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.rock[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = rock ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = rock ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  

}


 


round(apply(evalData.rock,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.rock,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])
# 


```



# overall performance
```{r}

#overall model performance

evals<- rbind(evalData.mud, evalData.mudSand, evalData.sand, evalData.gravel, evalData.cob, evalData.rock)

round(apply(evals,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


```




## rock model predictions
```{r}

### GAM_OK
#For this we will not use any test/train partition but the entire dataset:

# refit model to all


GAM1 <- gam(formula = rock ~  s(x,y)+ s(depth), data = sub.spdfT, family = binomial)
summary(GAM1)
#plot(GAM1)

## make data frame for predictions

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val,'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)
head(PredGAM)

coord.tmp<- cbind(PredGAM$x, PredGAM$y)
rock.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(rock.spdf) <- CRS.wgs84
rock.spdfT<- spTransform(rock.spdf,  CRS.NG)

#plot(rock.spdfT)




rock.r<-rasterize(rock.spdfT, depth, 'fit', fun=mean)
#plot(rock.r)



#pdf(file="F:/SIFT2021/May on/report/rock_pred.pdf",width=6, height=6)



plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(rock.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)


plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "rock" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[8], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "rock" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[8], cex=1.1)

#plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "rock" ,], pch=19, add=T, col=
 #    brewer.pal(8,"Dark2")[6], cex=1.1)

#plot(sub.spdfT4.trim[sub.spdfT4.trim$Substratum4 == "rock" ,], pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[7], cex=1.1)


legend('bottomright', legend=leg, fill= c('1','1','1','1','1', brewer.pal(8,"Dark2")[c(8)]))

#dev.off()



```

## rock RF prediction
```{r}

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])
summary(mod.dat.rf)
mod.dat.rf<- na.omit(mod.dat.rf)
summary(mod.dat.rf)
names(sub)

RF.mod<- randomForest(y = as.factor(sub$rock), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)
summary(Pred.rf)
names(Pred.rf)[3]<- c('fit')
str(Pred.rf)
Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

rock.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(rock.rf.spdf) <- CRS.wgs84
rock.rf.spdfT<- spTransform(rock.rf.spdf,  CRS.NG)



rock.rf.r<-rasterize(rock.rf.spdfT, depth, 'fit', fun=mean)
#plot(rock.rf.r)


#pdf(file="F:/SIFT2021/May on/report/rock_RF.pdf",width=6, height=6)


plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(rock.rf.r, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "rock" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[8], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "rock" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[8], cex=1.1)

#plot(sub.spdfT3.trim[sub.spdfT3.trim$Substratum3 == "rock" ,], pch=19, add=T, col=
 #    brewer.pal(8,"Dark2")[6], cex=1.1)

#plot(sub.spdfT4.trim[sub.spdfT4.trim$Substratum4 == "rock" ,], pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[7], cex=1.1)

legend('bottomright', legend=leg, fill= c('1','1','1','1','1', brewer.pal(8,"Dark2")[c(8)]))

#dev.off()

```


#rock krig
```{r}

# re fit model to all data

 formMod <- rock ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  plot(variog, variogFitOLS, main="OLS Model")
#
  
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



# make depth raster
rock.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


rock.k<- rescale0to1(rock.k)




#pdf(file="F:/SIFT2021/May on/report/rock_K_pred.pdf",width=6, height=6)

plot(sub.spdfT, col='white')
plot(hill, col=hill.col(1000), legend=F)
plot(rock.k, add=T, legend=FALSE, axes=FALSE)
plot(shore, col='black', add=T, lwd=1)

plot(sub.spdfT, pch=19, add=T, col=
       'black', cex=1)

plot(sub.spdfT[sub.spdfT$Substratum1 == "rock" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[8], cex=1.1)

plot(sub.spdfT2.trim[sub.spdfT2.trim$Substratum2 == "rock" ,], pch=19, add=T, col=
       brewer.pal(8,"Dark2")[8], cex=1.1)

#plot(sub.pdfT3.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT3.trim@data$Substratum3], cex=0.5)

#plot(sub.spdfT4.trim, pch=19, add=T, col=
#       brewer.pal(8,"Dark2")[1][sub.spdfT4.trim@data$Substratum4], cex=2.4)


legend('bottomright', legend=leg, fill=c('black', 'black', 'black', 'black', 'black', brewer.pal(8,"Dark2")[c(8)] ))


#dev.off()

#hist(rock.k)


```




# model plots legend
```{r}

#pdf(file="F:/SIFT2021/May on/report/preds_legend.pdf",width=4.5, height=4.5)

image.plot((mud.r), horizontal=T, smallplot= c(0.1, 0.9,0.6,0.63), col = rev(terrain.colors(1000)), legend.only=TRUE,  axis.args = list(cex.axis = 1,
at = c(0, 50, 100), labels =c("0","0.5","1.0"), 
tcl=0.3, lwd=0.5, hadj=0.5), axes=F, zlim=c(0, 100))

#dev.off()

```



# overall performance
```{r}

#overall model performance

evals<- rbind(evalData.mud, evalData.mudSand, evalData.sand, evalData.gravel, evalData.cob, evalData.rock)

round(apply(evals,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


```



### performance loop
```{r}



    
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF object
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.mud <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
 
 #number of iterations
N<- 100
first.run=TRUE

for (i in 1:N){

 
 
 
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "mud"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- mud ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mud[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "mud"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mud[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = mud ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = mud ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
}




#muddy_sand
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "muddy_sand"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- muddy_sand ~ x+y+ depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mudSand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "muddy_sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mudSand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)


#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = muddy_sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  
 


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = muddy_sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 

}




#sand
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "sand"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- sand ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.sand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.sand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))




#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 

}





#gravel
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "gravel"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- gravel ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.gravel[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "gravel"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.gravel[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = gravel ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 



#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = gravel ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
  

}


 


# cobble boulder
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "cob_boulder"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- cob_boulder ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.cob[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "cob_boulder"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.cob[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 
  

#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = cob_boulder ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = cob_boulder ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 
}


 


#rock
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "rock"]
#   
#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## Ordinary Kriging ----
#   ## ----------------------------------------------------------------------------- ##
#     
  # Make variogram
  formMod <- rock ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
 # plot(variog, variogFitOLS, main="OLS Model")
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.rock[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   ## ----------------------------------------------------------------------------- ##
#   ## RF calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  RF <- randomForest(y = as.factor(sub[idx, "rock"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.rock[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  #

  

#   
#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GLM calibration ----
#   ## ----------------------------------------------------------------------------- ##
# 
  GLM <- glm(formula = rock ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))




#   
#   ## ----------------------------------------------------------------------------- ##
#   ## GAM calibration ----
#   ## ----------------------------------------------------------------------------- ##
#   
  GAM <- gam(formula = rock ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))


}




# 


if(first.run==TRUE){


evals<- rbind(evalData.mud, evalData.mudSand, evalData.sand, evalData.gravel, evalData.cob, evalData.rock)

}  else {
 
 evals.tmp<- rbind(evalData.mud, evalData.mudSand, evalData.sand, evalData.gravel, evalData.cob, evalData.rock)
 
 evals<- rbind(evals, evals.tmp)
       
}

print(evals)
first.run=FALSE

}


round(apply(evals,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)



```



## combined map
```{r}
# make a set of colour pallets for mud, muddy_sand, sand, gravel, cob_boulder and rock...so 6 in all.
# 
# # Trim each raster to only contain values of reasonable magnitude
# density(mud.r)
# density(muddy_sand.r)
# density(sand.r)
# density(gravel.r)
# density(cob_boulder.r)
# density(rock.r)

# write files for later use
#writeRaster(mud.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/mud_pred.grd', format='raster')
#writeRaster(mud.rf.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/mud_pred_rf.grd', format='raster')
#writeRaster(mud.k, 'F:/SIFT2021/May on/GIS_data/analysis_files/mud_pred_k.grd', format='raster')

#writeRaster(muddy_sand.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/muddy_s_pred.grd', format='raster')
#writeRaster(muddy_sand.rf.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/muddy_s_rf_pred.grd', format='raster')
#writeRaster(muddy_sand.k, 'F:/SIFT2021/May on/GIS_data/analysis_files/muddy_s_k_pred.grd', format='raster')

#writeRaster(sand.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/sand_pred.grd', format='raster')
#writeRaster(sand.rf.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/sand_rf_pred.grd', format='raster')
#writeRaster(sand.k, 'F:/SIFT2021/May on/GIS_data/analysis_files/sand_k_pred.grd', format='raster')

#writeRaster(gravel.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/gravel_pred.grd', format='raster')
#writeRaster(gravel.rf.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/gravel_rf_pred.grd', format='raster')
#writeRaster(gravel.k, 'F:/SIFT2021/May on/GIS_data/analysis_files/gravel_k_pred.grd', format='raster')


#writeRaster(cob_boulder.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/cob_boul_pred.grd', format='raster')
#writeRaster(cob_boulder.rf.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/cob_boul_rf_pred.grd', format='raster')
#writeRaster(cob_boulder.k, 'F:/SIFT2021/May on/GIS_data/analysis_files/cob_boul_k_pred.grd', format='raster')

#writeRaster(rock.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/rock_pred.grd', format='raster')
#writeRaster(rock.rf.r, 'F:/SIFT2021/May on/GIS_data/analysis_files/rock_rf_pred.grd', format='raster')
#writeRaster(rock.k, 'F:/SIFT2021/May on/GIS_data/analysis_files/rock_k_pred.grd', format='raster')
# 
# 
# mud.trim<- mud.r
# muddy_sand.trim<- muddy_sand.r
# sand.trim<- sand.r
# gravel.trim<- gravel.r
# cob_boulder.trim<- cob_boulder.r
# rock.trim<- rock.r
# 
# 
# density(mud.r)
# mud.trim [mud.trim< 0.51] <- NA
# density(mud.trim)

# 
# 
# density(muddy_sand.r)
# muddy_sand.trim [muddy_sand.trim< 0.51] <- NA
# density(muddy_sand.trim)
# 
# 
# 
# density(sand.r)
# sand.trim [sand.trim< 0.11] <- NA
# density(sand.trim)
# 
# density (gravel.r)
# gravel.trim [gravel.trim< 0.05] <- NA
# density(gravel.trim)

# density(cob_boulder.r)
# cob_boulder.trim [cob_boulder.trim< 0.11] <- NA
# density(cob_boulder.trim)
# 
# density(rock.r)
# rock.trim [rock.trim< 0.51] <- NA
# density(rock.trim)
# 
# 
# #display.brewer.all()
# mud.heat<- colorRampPalette(brewer.pal(9,'YlOrRd')[c(1,4:8)], alpha=TRUE)
# muddy_s.heat<- colorRampPalette(brewer.pal(9,'Purples')[c(1,4:8)], alpha=TRUE)
# sand.heat<- colorRampPalette(brewer.pal(9,'YlOrRd')[c(1:4)], alpha=TRUE, bias=2)
# gravel.heat<- colorRampPalette(brewer.pal(9,'Greys')[c(5:9)], alpha=TRUE)
# cob_boul.heat<- colorRampPalette(brewer.pal(9,'Greens')[c(1,5:9)], alpha=TRUE)
# rock.heat<- colorRampPalette(brewer.pal(9,'Blues')[c(1,5:9)], alpha=TRUE)
# 
# 
# # addalpha()
# addalpha <- function(colors, alpha=1.0) {
#   r <- col2rgb(colors, alpha=T)
#   # Apply alpha
#   r[4,] <- alpha*255
#   r <- r/255.0
#   return(rgb(r[1,], r[2,], r[3,], r[4,]))
# }

# 
# mud.alt <- colorRampPalette(c('coral', brewer.pal(8,'Dark2')[c(2)]), alpha=TRUE, bias=1)
# mud.s.alt <- colorRampPalette(c('deepskyblue', brewer.pal(8,'Dark2')[c(3)]), alpha=TRUE, bias=1)
# sand.alt <- colorRampPalette(c('mistyrose',  brewer.pal(8,'Dark2')[c(4)]), alpha=TRUE, bias=1)
# gravel.alt <- colorRampPalette(c('darkolivegreen1', 'green4'), alpha=TRUE, bias=1)
# cob_bol.alt<- colorRampPalette(c('lightgoldenrod1', brewer.pal(8,'Dark2')[c(6)]), alpha=TRUE, bias=1)
# rock.alt<- colorRampPalette(c('snow3', brewer.pal(8,'Dark2')[c(8)]), alpha=TRUE, bias=1)
# 
# 
# 
# #pdf(file="F:/SIFT2021/May on/report/cobined_pred_alt.pdf",width=6, height=6)
# 
# plot(sub.spdfT, col='white')
# plot(hill, col=hill.col(1000), legend=F)
# 
# 
# 
# plot(sand.trim, add=T, legend=FALSE, axes=FALSE, col=sand.alt(1000), alpha=0.8)
# 
# 
# plot(cob_boulder.trim, add=T, legend=FALSE, axes=FALSE, col=cob_bol.alt(1000), alpha=0.6)
# 
# plot(gravel.trim, add=T, legend=FALSE, axes=FALSE, col=gravel.alt(1000), alpha=0.4)
# 
# plot(muddy_sand.trim, add=T, legend=FALSE, axes=FALSE, col=mud.s.alt(1000), alpha=0.5)

#plot(sand.trim, add=T, legend=FALSE, axes=FALSE, col=sand.heat(1000), alpha=0.5)
# 
# 
# plot(rock.trim, add=T, legend=FALSE, axes=FALSE, col=rock.alt(1000), alpha=0.8)
# 
# 
# plot(mud.trim, add=T, legend=FALSE, axes=FALSE, col=mud.alt(1000), alpha=0.5)

# 
# 
# plot(shore, col='black', add=T, lwd=1)
# 
# leg.cols<- c(brewer.pal(9,'YlOrRd')[7],  brewer.pal(9,'Purples')[7], brewer.pal(9,'YlOrRd')[4], brewer.pal(9,'Greys')[4], brewer.pal(9,'Greens')[8],brewer.pal(9,'Blues')[7])
# 
# alt.cols<-brewer.pal(8,"Dark2")[c(2:6,8)]

# legend('bottomright', legend=leg, fill= alt.cols)

#dev.off()

```


##
## area calcs-  wider area combined map
```{r}
# make a set of colour pallets for mud, muddy_sand, sand, gravel, cob_boulder and rock...so 6 in all.
# 
# # Trim each raster to only contain values of resaonable magnitude
# density(mud.r)
# density(muddy_sand.r)
# density(sand.r)
# density(gravel.r)
# density(cob_boulder.r)
# density(rock.r)
# 
# mud.trim<- mud.r
# muddy_sand.trim<- muddy_sand.r
# sand.trim<- sand.r
# gravel.trim<- gravel.r
# cob_boulder.trim<- cob_boulder.r
# rock.trim<- rock.r
# 
# 
# #hist(mud.r)
# mud.trim [mud.trim<= 0.1] <- NA
# density(mud.trim)
# 
# 
# ###area calc
# plot(mud.trim, colNA="dodgerblue")
# 
# cell.No<-cellStats(mud.trim, function(i, ...) sum(!is.na(i)))
# 
# raster_area<- cell.No * (res(mud.trim)[1]*res(mud.trim)[2])
# 
# #area at >0.1
# round(raster_area/(1000*1000), 2)
# 
# #proportion
# round(round(raster_area/(1000*1000), 2)/total.area,3)
# 
# density(muddy_sand.r)
# muddy_sand.trim [muddy_sand.trim<= 0.1] <- NA
# density(muddy_sand.trim)
# 
# ###area calc
# plot(muddy_sand.trim, colNA="dodgerblue")
# 
# cell.No<-cellStats(muddy_sand.trim, function(i, ...) sum(!is.na(i)))
# 
# raster_area<- cell.No * (res(muddy_sand.trim)[1]*res(muddy_sand.trim)[2])
# 
# #area at >0.1
# round(raster_area/(1000*1000), 2)
# 
# #proportion
# round(round(raster_area/(1000*1000), 2)/total.area,3)
# 
# density(sand.r)
# sand.trim [sand.trim<= 0.1] <- NA
# density(sand.trim)
# 
# ###area calc
# plot(sand.trim, colNA="dodgerblue")
# 
# cell.No<-cellStats(sand.trim, function(i, ...) sum(!is.na(i)))
# 
# raster_area<- cell.No * (res(sand.trim)[1]*res(sand.trim)[2])
# 
# #area at >0.1
# round(raster_area/(1000*1000), 2)
# #proportion
# round(round(raster_area/(1000*1000), 2)/total.area,3)
# 
# 
# 
# density (gravel.r)
# gravel.trim [gravel.trim <= 0.1] <- NA
# density(gravel.trim)
# 
# ###area calc
# plot(gravel.trim, colNA="dodgerblue")
# 
# cell.No<-cellStats(gravel.trim, function(i, ...) sum(!is.na(i)))
# 
# raster_area<- cell.No * (res(gravel.trim)[1]*res(gravel.trim)[2])
# 
# #area at >0.1
# round(raster_area/(1000*1000), 2)
# #proportion
# round(round(raster_area/(1000*1000), 2)/total.area,3)
# 
# density(cob_boulder.r)
# cob_boulder.trim [cob_boulder.trim<= 0.1] <- NA
# density(cob_boulder.trim)
# 
# ###area calc
# plot(cob_boulder.trim, colNA="dodgerblue")
# 
# cell.No<-cellStats(cob_boulder.trim, function(i, ...) sum(!is.na(i)))
# 
# raster_area<- cell.No * (res(cob_boulder.trim)[1]*res(cob_boulder.trim)[2])
# 
# #area at >0.1
# round(raster_area/(1000*1000), 2)
# #proportion
# round(round(raster_area/(1000*1000), 2)/total.area,3)
# 
# density(rock.r)
# rock.trim [rock.trim<= 0.1] <- NA
# density(rock.trim)
# 
# ###area calc
# plot(rock.trim, colNA="dodgerblue")
# 
# cell.No<-cellStats(rock.trim, function(i, ...) sum(!is.na(i)))
# 
# raster_area<- cell.No * (res(rock.trim)[1]*res(rock.trim)[2])
# 
# #area at >0.1
# round(raster_area/(1000*1000), 2)
# #proportion
# round(round(raster_area/(1000*1000), 2)/total.area,3)
# 
# 
# #display.brewer.all()
# mud.heat<- colorRampPalette(brewer.pal(9,'YlOrRd')[c(1,4:8)], alpha=TRUE)
# muddy_s.heat<- colorRampPalette(brewer.pal(9,'Purples')[c(1,4:8)], alpha=TRUE)
# sand.heat<- colorRampPalette(brewer.pal(9,'YlOrRd')[c(1:4)], alpha=TRUE, bias=2)
# gravel.heat<- colorRampPalette(brewer.pal(9,'Greys')[c(5:9)], alpha=TRUE)
# cob_boul.heat<- colorRampPalette(brewer.pal(9,'Greens')[c(1,5:9)], alpha=TRUE)
# rock.heat<- colorRampPalette(brewer.pal(9,'Blues')[c(1,5:9)], alpha=TRUE)
# 
# 
# plot(sub.spdfT, col='white')
# plot(hill, col=hill.col(1000), legend=F)
# 
# 
# 
# plot(sand.r, add=T, legend=FALSE, axes=FALSE, col=sand.heat(1000), alpha=0.6)
# 
# 
# plot(cob_boulder.trim, add=T, legend=FALSE, axes=FALSE, col=cob_boul.heat(1000), alpha=0.7)
# 
# plot(gravel.trim, add=T, legend=FALSE, axes=FALSE, col=gravel.heat(1000), alpha=0.6)
# 
# plot(muddy_sand.trim, add=T, legend=FALSE, axes=FALSE, col=muddy_s.heat(1000), alpha=0.35)
# 
# plot(sand.trim, add=T, legend=FALSE, axes=FALSE, col=sand.heat(1000), alpha=0.4)
# 
# 
# plot(rock.trim, add=T, legend=FALSE, axes=FALSE, col=rock.heat(1000), alpha=0.8)
# 
# 
# plot(mud.trim, add=T, legend=FALSE, axes=FALSE, col=mud.heat(1000), alpha=0.5)
# 
# 
# 
# plot(shore, col='black', add=T, lwd=1)
# 
# leg.cols<- c(brewer.pal(9,'YlOrRd')[7],  brewer.pal(9,'Purples')[7], brewer.pal(9,'YlOrRd')[4], brewer.pal(9,'Greys')[4], brewer.pal(9,'Greens')[8],brewer.pal(9,'Blues')[7])
# 
# 
# legend('bottomright', legend=levels(sub.spdfT@data$Substratum1), fill= leg.cols)



```

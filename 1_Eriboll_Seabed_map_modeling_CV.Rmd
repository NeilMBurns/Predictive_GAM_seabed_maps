---
title: "Loch Eriboll seabed map"
output:
  word_document: default
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: console
---

#setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#required packages
 library(sp)
 library(RColorBrewer)
 library(fields)
 library(raster)
 library(rgdal)
 library(gstat)
 library(randomForest)
 library(mgcv)
 library(climateStability)


########## import data ########

### Shape files in Data/GIS folder 
#                       - shore <- shoreline.shp


# map extent
new.ext<- extent(c(xmin=238800, xmax=252000, ymin=953700, ymax=969700))
new.ext

shore<- crop(shore, new.ext)

### rasters
# in Data/GIS folder- depth <- bathy.grd
#                   -  slo <- slope.grd
#                   -  asp <- aspect.grd


# Data file in data folder
#                   - dat<- Loch_Eriboll_substratum_combine_cob_boulder.csv

## data tidy

sub<- subset(dat, dat$Substratum1!='')
sub<- sub[,-12]
sub<- droplevels(sub)


sub$Substratum1<- as.factor(sub$Substratum1)
sub$Substratum2<- as.factor(sub$Substratum2)
sub$Substratum3<- as.factor(sub$Substratum3)

sub$Substratum1<- factor(sub$Substratum1, levels = c("mud", "muddy_sand","sand", "gravel", "cob_boulder", "rock"))

sub$Substratum2<- factor(sub$Substratum2, levels = c("mud", "muddy_sand","sand", "gravel", "cob_boulder", "rock"))

sub$Substratum3<- factor(sub$Substratum3, levels = c("sand", "cob_boulder"))



################################## coord system to assign 
###

#'#set CRS
CRS1.code <- CRS(SRS_string='EPSG:4326')

#Display the stored CRS using comment()
cat(comment(CRS1.code), "\n")
# Store the wkt in a variable
wkt1 <- comment(CRS1.code)

# Use this to assign the CRS of another sp-object
CRS.wgs84 <- CRS(SRS_string = wkt1)

### projections ####


CRS2.code <- CRS(SRS_string='EPSG:27700')
#Display the stored CRS using comment()
cat(comment(CRS2.code), "\n")
# Store the wkt in a variable
wkt2 <- comment(CRS2.code)

# Use this to assign the CRS of another sp-object
CRS.NG <- CRS(SRS_string = wkt2)


## make an spdf from the data
coord.tmp<- cbind(sub$x, sub$y)
sub.spdf<- SpatialPointsDataFrame(coord.tmp, data=data.frame(sub))
proj4string(sub.spdf) <- CRS.wgs84
sub.spdfT<- spTransform(sub.spdf,  CRS.NG)


```


#background map
```{r}


hill<- hillShade(slo, asp, angle=55, direction=100, normalize =T)


hill.col<- colorRampPalette(c('floralwhite','antiquewhite1', 'antiquewhite2', 'antiquewhite3', 'antiquewhite4'), bias=0.5)


depth.heat<- colorRampPalette(rev(brewer.pal(9,'Blues')[2:9]))



plot(hill, col=hill.col(1000), legend=F)
plot(depth, add=T, legend=F, col=depth.heat(1000))


```



# Substrata vecrors tidy 
```{r}

sub.spdfT@data$Substratum2<- as.factor(sub.spdfT@data$Substratum2)
sub.spdfT@data$Substratum3<- as.factor(sub.spdfT@data$Substratum3)


sub.spdfT2<- sub.spdfT[,10]
sub.spdfT3<- sub.spdfT[,11]

sp.na.omit <- function(x, margin=1) {
  if (!inherits(x, "SpatialPointsDataFrame") & !inherits(x, "SpatialPolygonsDataFrame")) 
    stop("MUST BE sp SpatialPointsDataFrame OR SpatialPolygonsDataFrame CLASS OBJECT") 
  na.index <- unique(as.data.frame(which(is.na(x@data),arr.ind=TRUE))[,margin])
    if(margin == 1) {  
      cat("DELETING ROWS: ", na.index, "\n") 
        return( x[-na.index,]  ) 
    }
    if(margin == 2) {  
      cat("DELETING COLUMNS: ", na.index, "\n") 
        return( x[,-na.index]  ) 
    }
 }

sub.spdfT2.trim <- sp.na.omit(sub.spdfT2)     
  dim(sub.spdfT2)
    dim(sub.spdfT2.trim)
    
sub.spdfT2.trim@data$Substratum2<- factor(sub.spdfT2.trim@data$Substratum2, levels = c("mud", "muddy_sand","sand", "gravel", "cob_boulder", "rock"))

  
sub.spdfT3.trim <- sp.na.omit(sub.spdfT3)     
  dim(sub.spdfT3)
    dim(sub.spdfT3.trim) 
    
sub.spdfT3.trim@data$Substratum3<- factor(sub.spdfT3.trim@data$Substratum3, levels = c("sand", "cob_boulder"))
    
```


#Model fitting
#Mud
```{r}

# # Check data for duplicates
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
# define functions for creating the k-fold train/test data splits a and regression residuals from RF object, initialise evaluation matrix


K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 

resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.mud <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 

# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN #
  idx <- kfolds[[i]]

  # TRAIN #
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data #
   obs.test <- sub[!idxBool, "mud"]
#   
#   
#  
# Ordinary Kriging

  # variogram
  formMod <- mud ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by OLS
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mud[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))



# RF calibration  
# 
  RF <- randomForest(y = as.factor(sub[idx, "mud"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mud[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  
# GLM calibration
# 
# 
  GLM <- glm(formula = mud ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  



# GAM calibration

#   
  GAM <- gam(formula = mud ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  

}


round(apply(evalData.mud,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.mud,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])


```


## Mud model predictions
```{r}

### GAM
# refit model to all


GAM1 <- gam(formula = mud ~  s(x, y)+ depth, data = sub.spdfT, family = binomial)
summary(GAM1)

## make data frame for predictions

#plot(depth)
depth_wgs<- projectRaster(depth, crs=CRS.wgs84)
#plot(depth_wgs)
depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'= xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)


coord.tmp<- cbind(PredGAM$x, PredGAM$y)
mud.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(mud.spdf) <- CRS.wgs84
mud.spdfT<- spTransform(mud.spdf,  CRS.NG)

mud.r<-rasterize(mud.spdfT, depth, 'fit', fun=mean)

```

## Mud RF prediction
```{r}


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])

mod.dat.rf<- na.omit(mod.dat.rf)


RF.mod<- randomForest(y = as.factor(sub$mud), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)

names(Pred.rf)[3]<- c('fit')

Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

mud.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(mud.rf.spdf) <- CRS.wgs84
mud.rf.spdfT<- spTransform(mud.rf.spdf,  CRS.NG)



mud.rf.r<-rasterize(mud.rf.spdfT, depth, 'fit')

```

##mud krig
```{r}

# re fit model to all data

 formMod <- mud ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  
#


xy<- projectRaster(depth, crs=CRS.wgs84, method="bilinear")
new.dat<- data.frame(rasterToPoints(xy,spatial=F))
colnames(new.dat)<- c('x','y', 'depth')

 coord.tmp<- cbind(new.dat$x, new.dat$y)
new.dat.spdf<- SpatialPointsDataFrame(coord.tmp, data=data.frame(new.dat),  proj4string= CRS.wgs84)
new.dat.spdfT<- sp::spTransform(new.dat.spdf, CRS.NG)    
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



mud.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


mud.k<- rescale0to1(mud.k)


```


# Muddy_sand
```{r}
 
# 
# # Check data for duplicates
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)


K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 

resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))
# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.mudSand <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
#
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN 
  idx <- kfolds[[i]]

  # TRAIN 
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data
   obs.test <- sub[!idxBool, "muddy_sand"]
#   
#   
#   

#  Ordinary Kriging
# 
#     
  # variogram
  formMod <- muddy_sand ~ x+y+ depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by OLS
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)

#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mudSand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   

# RF calibration
# 
  RF <- randomForest(y = as.factor(sub[idx, "muddy_sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mudSand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  
#   
#   

# GLM calibration

# 
  GLM <- glm(formula = muddy_sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 


#   

# GAM calibration
#   
#   
  GAM <- gam(formula = muddy_sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
}



round(apply(evalData.mudSand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.mudSand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])


```


## Muddy_sand model predictions
```{r}

#
# refit model to all


GAM1 <- gam(formula = muddy_sand ~  s(x, y)+ depth, data = sub.spdfT, family = binomial)

## make data frame for predictions


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'= xy[,1],'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)


coord.tmp<- cbind(PredGAM$x, PredGAM$y)
muddy_sand.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(muddy_sand.spdf) <- CRS.wgs84
muddy_sand.spdfT<- spTransform(muddy_sand.spdf,  CRS.NG)


muddy_sand.r<-rasterize(muddy_sand.spdfT, depth, 'fit', fun=mean)


```

## Muddy_sand RF prediction
```{r}


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])

mod.dat.rf<- na.omit(mod.dat.rf)



RF.mod<- randomForest(y = as.factor(sub$muddy_sand), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)

names(Pred.rf)[3]<- c('fit')

Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

muddy_sand.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(muddy_sand.rf.spdf) <- CRS.wgs84
muddy_sand.rf.spdfT<- spTransform(muddy_sand.rf.spdf,  CRS.NG)


muddy_sand.rf.r<-rasterize(muddy_sand.rf.spdfT, depth, 'fit', fun=mean)

```


##muddy_sand krig
```{r}

# re fit model to all data

 formMod <- muddy_sand ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
  
#
  
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)




muddy_sand.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


muddy_sand.k<- rescale0to1(muddy_sand.k)

```


# sand
```{r}

# 
# # Check data for duplicates.
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)

# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 

resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.sand <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 

# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN 
  idx <- kfolds[[i]]

  # TRAIN 
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test
   obs.test <- sub[!idxBool, "sand"]
#   
#   
#Ordinary Kriging
#     
  # Make variogram
  formMod <- sand ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.sand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))



# RF calibration
# 
  RF <- randomForest(y = as.factor(sub[idx, "sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.sand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 

#GLM calibration
# 
  GLM <- glm(formula = sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 

#GAM calibration
#
#   
  GAM <- gam(formula = sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 
}


round(apply(evalData.sand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.sand,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])

```


## sand model predictions
```{r}

# refit model to all

GAM1 <- gam(formula = sand ~  s(x, y)+ depth, data = sub.spdfT, family = binomial)


## make data frame for predictions


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)


coord.tmp<- cbind(PredGAM$x, PredGAM$y)
sand.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(sand.spdf) <- CRS.wgs84
sand.spdfT<- spTransform(sand.spdf,  CRS.NG)


sand.r<-rasterize(sand.spdfT, depth, 'fit', fun=mean)


```

## sand RF prediction
```{r}

depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])

mod.dat.rf<- na.omit(mod.dat.rf)

RF.mod<- randomForest(y = as.factor(sub$sand), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)

names(Pred.rf)[3]<- c('fit')

Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

sand.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(sand.rf.spdf) <- CRS.wgs84
sand.rf.spdfT<- spTransform(sand.rf.spdf,  CRS.NG)

sand.rf.r<-rasterize(sand.rf.spdfT, depth, 'fit', fun=mean)

```


##sand krig
```{r}

# re fit model to all data

 formMod <- sand ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram 
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
  
  
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



sand.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


sand.k<- rescale0to1(sand.k)


```



# gravel
```{r}
# 

# # Check data for duplicates
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)


# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 

resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.gravel <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN indices as integer
  idx <- kfolds[[i]]

  # TRAIN indices as a boolean vector
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data for the target variable
   obs.test <- sub[!idxBool, "gravel"]
#   

#Ordinary Kriging

#     
  # Make variogram
  formMod <- gravel ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.gravel[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))



#   RF calibration
# 
  RF <- randomForest(y = as.factor(sub[idx, "gravel"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.gravel[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 
#   
#GLM calibration
# 
  GLM <- glm(formula = gravel ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  
#GAM calibration
#   
  GAM <- gam(formula = gravel ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  

}


round(apply(evalData.gravel,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.gravel,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])


```


## gravel model predictions
```{r}


# refit model to all

GAM1 <- gam(formula = gravel ~  s(x,y)+ depth, data = sub.spdfT, family = binomial)


## make data frame for predictions


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val, 'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)


coord.tmp<- cbind(PredGAM$x, PredGAM$y)
gravel.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(gravel.spdf) <- CRS.wgs84
gravel.spdfT<- spTransform(gravel.spdf,  CRS.NG)


gravel.r<-rasterize(gravel.spdfT, depth, 'fit', fun=mean)

```

## gravel RF prediction
```{r}


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])

mod.dat.rf<- na.omit(mod.dat.rf)


RF.mod<- randomForest(y = as.factor(sub$gravel), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)

names(Pred.rf)[3]<- c('fit')

Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

gravel.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(gravel.rf.spdf) <- CRS.wgs84
gravel.rf.spdfT<- spTransform(gravel.rf.spdf,  CRS.NG)



gravel.rf.r<-rasterize(gravel.rf.spdfT, depth, 'fit', fun=mean)


```


##gravel krig
```{r}

# re fit model to all data

 formMod <- gravel ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)

  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)




gravel.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


gravel.k<- rescale0to1(gravel.k)


```



#Cobble-boulder
```{r}

# 
# # Check data for duplicates.
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)


# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 

resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))



# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.cob <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 

# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN 
  idx <- kfolds[[i]]

  # TRAIN 
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data 
   obs.test <- sub[!idxBool, "cob_boulder"]
#   

# Ordinary Kriging
#     
  # Make variogram
  formMod <- cob_boulder ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram 
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.cob[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))



#RF calibration
# 
  RF <- randomForest(y = as.factor(sub[idx, "cob_boulder"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.cob[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  


#GLM calibration
# 
  GLM <- glm(formula = cob_boulder ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  


#  GAM calibration
#   
  GAM <- gam(formula = cob_boulder ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
}


round(apply(evalData.cob,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.cob,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])


```


## Cob_boulder model predictions
```{r}


# refit model to all


GAM1 <- gam(formula = cob_boulder ~  s(x,y)+ depth, data = sub.spdfT, family = binomial)


## make data frame for predictions


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val,'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)

coord.tmp<- cbind(PredGAM$x, PredGAM$y)
cob_boulder.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(cob_boulder.spdf) <- CRS.wgs84
cob_boulder.spdfT<- spTransform(cob_boulder.spdf,  CRS.NG)

cob_boulder.r<-rasterize(cob_boulder.spdfT, depth, 'fit', fun=mean)


```

## Cob-boulder RF prediction
```{r}


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])

mod.dat.rf<- na.omit(mod.dat.rf)


RF.mod<- randomForest(y = as.factor(sub$cob_boulder), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)

names(Pred.rf)[3]<- c('fit')

Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

cob_boulder.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(cob_boulder.rf.spdf) <- CRS.wgs84
cob_boulder.rf.spdfT<- spTransform(cob_boulder.rf.spdf,  CRS.NG)



cob_boulder.rf.r<-rasterize(cob_boulder.rf.spdfT, depth, 'fit', fun=mean)

```


##Cob_boulder krig
```{r}

# re fit model to all data

 formMod <- cob_boulder ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram 
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
     
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)



cob_boulder.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


cob_boulder.k<- rescale0to1(cob_boulder.k)


```


# rock
```{r}
# 
# 
# # Check data for duplicates.
nrow(sub)
summary(sub$Substratum1)
zerodist(sub.spdfT, zero = 0.0, unique.ID = FALSE, memcmp = TRUE)


# 
K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 

resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# 
# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.rock <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 

# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN 
  idx <- kfolds[[i]]

  # TRAIN 
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data 
   obs.test <- sub[!idxBool, "rock"]
#   
#Ordinary Kriging
#     
  # Make variogram
  formMod <- rock ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)

#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.rock[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))



# RF calibration
#
# 
  RF <- randomForest(y = as.factor(sub[idx, "rock"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.rock[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  

# GLM calibration
# 
  GLM <- glm(formula = rock ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))


# GAM calibration
#   
  GAM <- gam(formula = rock ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  

}



round(apply(evalData.rock,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


min(round(apply(evalData.rock,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x,na.rm=TRUE))),3)[1,])



```



## rock model predictions
```{r}

# refit model to all

GAM1 <- gam(formula = rock ~  s(x,y)+ s(depth), data = sub.spdfT, family = binomial)


## make data frame for predictions


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat<- data.frame('depth'=depth.val,'x'=xy[,1], 'y'= xy[,2])


PredGAM <- as.data.frame(predict(GAM1, newdata=mod.dat, type="response", se.fit=T))
PredGAM<- cbind(xy, PredGAM, 'depth'=mod.dat$depth)


coord.tmp<- cbind(PredGAM$x, PredGAM$y)
rock.spdf<- SpatialPointsDataFrame(coord.tmp, data=PredGAM)
proj4string(rock.spdf) <- CRS.wgs84
rock.spdfT<- spTransform(rock.spdf,  CRS.NG)



rock.r<-rasterize(rock.spdfT, depth, 'fit', fun=mean)


```

## rock RF prediction
```{r}


depth_wgs<- projectRaster(depth, crs=CRS.wgs84)

depth.val<- getValues(depth_wgs)
xy<- coordinates(depth_wgs)

mod.dat.rf<- data.frame('depth'=depth.val, 'y'= xy[,2], 'x'=xy[,1])
summary(mod.dat.rf)
mod.dat.rf<- na.omit(mod.dat.rf)
summary(mod.dat.rf)
names(sub)

RF.mod<- randomForest(y = as.factor(sub$rock), 
                     x = sub[,c( 2,3,13)],
                     ntree = 500,
                     mtry = 2)

 
rf.pred <- data.frame(predict(RF.mod, newdata =mod.dat.rf, type="response"))


Pred.rf <- cbind('y'= mod.dat.rf$y, 'x'= mod.dat.rf$x, rf.pred, 'depth'=mod.dat.rf$depth)

names(Pred.rf)[3]<- c('fit')

Pred.rf$fit<- as.numeric(Pred.rf$fit)

coord.tmp<- cbind(Pred.rf$x, Pred.rf$y)

rock.rf.spdf<- SpatialPointsDataFrame(coord.tmp, data=Pred.rf)
proj4string(rock.rf.spdf) <- CRS.wgs84
rock.rf.spdfT<- spTransform(rock.rf.spdf,  CRS.NG)



rock.rf.r<-rasterize(rock.rf.spdfT, depth, 'fit', fun=mean)

```


##rock krig
```{r}

# re fit model to all data

 formMod <- rock ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT)
#
#   # Variogram
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
  
  
#   # kriging predictions
  krig.est <- krige(formula = formMod ,
              locations = sub.spdfT,
              model = variogFitOLS,
              newdata = new.dat.spdfT,
              debug.level = 0)




rock.k<- rasterize(krig.est, depth, field = 'var1.pred', fun= mean)


rock.k<- rescale0to1(rock.k)

```



# overall performance
```{r}

#overall model performance

evals<- rbind(evalData.mud, evalData.mudSand, evalData.sand, evalData.gravel, evalData.cob, evalData.rock)

round(apply(evals,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)


```



### RMSE performance loop combined
```{r}

K<- 5

kfoldSplit <- function(x, k=K, train=TRUE){
  x <- sample(x, size = length(x), replace =FALSE)
  out <- suppressWarnings(split(x, factor(1:K)))
  if(train) out <- lapply(out, FUN = function(x, len) (1:len)[-x], len=length(unlist(out)))
  return(out)
}
# 
# # Regression residuals from RF 
resid.RF <- function(x) return(as.numeric(x$y) - as.numeric(x$predicted))


# 
 kfolds <- kfoldSplit(1:nrow(sub), k = K, train = TRUE)
# 
 evalData.mud <- matrix(NA, nrow=K, ncol=4, 
                    dimnames = list(1:K, c("OK","RF", "GLM","GAM")))
# 
# 
 
 #number of iterations
N<- 100
first.run=TRUE

for (i in 1:N){

 
 
 
# 
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN 
  idx <- kfolds[[i]]

  # TRAIN 
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data 
   obs.test <- sub[!idxBool, "mud"]
#   
#   
#   
#  OK
#     
  # Make variogram
  formMod <- mud ~ x+y +depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mud[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   RF
# 
  RF <- randomForest(y = as.factor(sub[idx, "mud"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mud[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  
#   
#   GLM
# 
  GLM <- glm(formula = mud ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  
#   GAM
#   
  GAM <- gam(formula = mud ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mud[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
}




#muddy_sand
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN
  idx <- kfolds[[i]]

  # TRAIN
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data
   obs.test <- sub[!idxBool, "muddy_sand"]
#   
#   
# OK
#     
  # Make variogram
  formMod <- muddy_sand ~ x+y+ depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.mudSand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   RF
# 
  RF <- randomForest(y = as.factor(sub[idx, "muddy_sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.mudSand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)


#   
#   GLM
# 
  GLM <- glm(formula = muddy_sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

  
 
# GAM
#  
#   
  GAM <- gam(formula = muddy_sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.mudSand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 

}




#sand
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN
  idx <- kfolds[[i]]

  # TRAIN
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data 
   obs.test <- sub[!idxBool, "sand"]
#   
#   
#  OK
#     
  # Make variogram
  formMod <- sand ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.sand[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   RF
# 
  RF <- randomForest(y = as.factor(sub[idx, "sand"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.sand[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 
#   GLM
# 
  GLM <- glm(formula = sand ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))




#   
# GAM
#   
  GAM <- gam(formula = sand ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.sand[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 

}





#gravel
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN
  idx <- kfolds[[i]]

  # TRAIN
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data
   obs.test <- sub[!idxBool, "gravel"]
#   

# OK
# 
#     
  # Make variogram
  formMod <- gravel ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram 
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.gravel[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#   RF
# 
  RF <- randomForest(y = as.factor(sub[idx, "gravel"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.gravel[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

#   
#   
#   GLM
# 
  GLM <- glm(formula = gravel ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 



#   GAM
#   
  GAM <- gam(formula = gravel ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.gravel[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

  
  

}



# cobble boulder
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN
  idx <- kfolds[[i]]

  # TRAIN 
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data
   obs.test <- sub[!idxBool, "cob_boulder"]
#   
#   
# OK
#   
#     
  # Make variogram
  formMod <- cob_boulder ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram fitting by Ordinary Least Sqaure
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.cob[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
# RF
# 
  RF <- randomForest(y = as.factor(sub[idx, "cob_boulder"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.cob[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

 
  

#   
#   
# GLM
# 
  GLM <- glm(formula = cob_boulder ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))

 


#   
#  GAM
#   
  GAM <- gam(formula = cob_boulder ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.cob[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))

 
}


 
#rock
for(i in 1:K){


  cat("K-fold...",i,"of",K,"....\n")

  # TRAIN
  idx <- kfolds[[i]]

  # TRAIN
  idxBool <- (1:nrow(sub)) %in% idx
#   
    # Observed test data
   obs.test <- sub[!idxBool, "rock"]
#   
#   
# OK
#     
  # Make variogram
  formMod <- rock ~ x+y+depth
  mod <- vgm(model  = "Exp")
  variog <- variogram(formMod, sub.spdfT[idxBool, ])
#
#   # Variogram
  variogFitOLS<-fit.variogram(variog, model = mod,  fit.method = 6)
#
#   # kriging predictions
  OK <- krige(formula = formMod ,
              locations = sub.spdfT[idxBool, ],
              model = variogFitOLS,
              newdata = sub.spdfT[!idxBool, ],
              debug.level = 0)

  ok.pred.test <- OK@data$var1.pred
  evalData.rock[i,"OK"] <- sqrt(mean((ok.pred.test - obs.test)^2))


#   
#  RF
# 
  RF <- randomForest(y = as.factor(sub[idx, "rock"]),
                     x = sub[idx, c('x', 'y', 'depth')],
                     ntree = 500,
                     mtry = 2)
#   
  rf.pred.test <- predict(RF, newdata = sub[-idx,c(2,3,13,18)], type="response")
  evalData.rock[i,"RF"] <- sqrt(mean(as.numeric(as.character(rf.pred.test)) - obs.test)^2)

  #

  

#   
#   
#GLM
# 
  GLM <- glm(formula = rock ~ depth + y, data =  sub.spdfT[idx, ], family='binomial')

  glm.pred.test <- predict(GLM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GLM"] <- sqrt(mean((glm.pred.test - obs.test)^2))




#   GAM
#   
  GAM <- gam(formula = rock ~  s(x, y)+ s(depth), data = sub.spdfT[idx, ], family = binomial)

  gam.pred.test <- predict(GAM, newdata = sub.spdfT[-idx,], type="response")
  evalData.rock[i,"GAM"] <- sqrt(mean((gam.pred.test - obs.test)^2))


}


if(first.run==TRUE){


evals<- rbind(evalData.mud, evalData.mudSand, evalData.sand, evalData.gravel, evalData.cob, evalData.rock)

}  else {
 
 evals.tmp<- rbind(evalData.mud, evalData.mudSand, evalData.sand, evalData.gravel, evalData.cob, evalData.rock)
 
 evals<- rbind(evals, evals.tmp)
       
}

print(evals)
first.run=FALSE

}


round(apply(evals,2,FUN = function(x, na.rm=TRUE) c(mean(x,na.rm=TRUE), sd(x, na.rm=TRUE))),3)



```

